//	Copyright 2013 - 2014, Alain Metge. All rights reserved. 
//
//		This file is part of hyperstore (http://www.hyperstore.org)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="../_references.ts" />
module Hyperstore
{
/**
 * Represents a domain model
 */
export class DomainModel {
    public events:EventManager;
    private _cache:{};
    public eventDispatcher:EventDispatcher;
    private _adapters:Adapter[];
    private graph:Hypergraph;

    /**
     * Domain model constructor
     * @param store : the store the domain belong to
     * @param name : domain name
     * @param extension: __internal use only. Use DomainModelScope constructor to create a domain extension
     */
    constructor(public store:Store, public name:string, public extension?:string) {
        this.name = this.name.toLowerCase();
        this.extension = extension;
        this.graph = new Hypergraph(this);
        store.__addDomain(this);
        this.events = new EventManager(this.name);
        this._cache = {};
        this._adapters = [];
    }

    dispose() {
        Utils.forEach(this._adapters, a=> a.dispose());

        this.graph.dispose();
        this.graph = undefined;
        this.events.dispose();
        this.events = undefined;
        this._cache = undefined;
        this.eventDispatcher = undefined;
    }

    /**
     * validate all elements of the domain
     * @param schemaElement - filter on a specific schemaElement
     * @returns {Array} - diagnostic messages (warnings or errors)
     */
    validate(schemaElement?:SchemaElement) : DiagnosticMessage[] {
        var groups = new HashTable<string,any>();
        Utils.forEach(this.getElements(schemaElement), (m:ModelElement) => {
            var sch = m.getInfo().schemaElement;
            var g = groups.get(sch.schema.name);
            if( !g) {
                g = {schema:sch.schema, elems:[]};
                groups.add(sch.schema.name,g);
            }
            g.elems.push(m);
        });

        var diags = [];
        Utils.forEach(groups, item => {
            diags = diags.concat( item.schema.constraints.validate(item.elems) );
        });
        return diags;
    }

    /**
     * create a new unique id for this domain.
     * An id is composed by two parts (the domain name and a unique id) separated by ':'
     * @param id - optional id. If not provided a new id will be generated
     * @returns {string} A domain id
     */
    createId(id?:string):string
    {
        return this.name + ":" + (id || Utils.newGuid()).toString();
    }

    /**
     * Add an adapter
     * @param adapter
     */
    addAdapter(adapter:Adapter)
    {
        var self = this;
        adapter.init(this);
        this._adapters.push(adapter);
    }

    /**
     *  Find a schema element by its id in the json compressed data
     * @param schemas - list of schema id from the json
     * @param id - index of the schema
     * @returns {any} - a valid schema id
     */
    private findSchemaId(schemas, id):string
    {
        if (schemas)
        {
            for (var k in schemas)
            {
                var schema = schemas[k];
                for (var ke in schema.elements)
                {
                    var e = schema.elements[ke];
                    if (e.id === id)
                    {
                        var schemaId;
                        if (schema.name == null) // null or undefined
                        {
                            schemaId = e.name;
                        }
                        else
                        {
                            schemaId = schema.name + ":" + e.name;
                        }

                        return schemaId;
                    }
                }
            }
        }
        return id;
    }

    /**
     * Load a domain from a json object. This object can have two specific format :
     * * hyperstore format. (generated by the hyperstore serializer)
     * * a poco object. For circular references, the newtonsoft format is used ($id and $ref) (http://james.newtonking.com/json/help/html/T_Newtonsoft_Json_PreserveReferencesHandling.htm)
     *
     * @param def
     * @param rootSchema
     * @returns {ModelElement[]}
     */
    loadFromJson(def:any, rootSchema?:SchemaElement):ModelElement[]
    {
        if (!def)
        {
            return;
        }

        if( typeof(def) === "string") {
            def = JSON.parse(def);
        }

        if (def.entities || def.relationships)
        {
            this.store.runInSession(() => this.loadFromHyperstoreJson(def));
            return;
        }

        if (!rootSchema)
        {
            throw "rootSchema is required";
        }
        var refs = {};
        if (Utils.isArray(def))
        {
            var list = [];
            this.store.runInSession(
                () =>
                {
                    Utils.forEach(def, e => list.push(this.parseJson(e, rootSchema, refs)));
                }
            );
            return list;
        }
        else
        {
            var r;
            this.store.runInSession(() => r = [this.parseJson(def, rootSchema, refs)]);
            return r;
        }
    }

    private parseJson(obj:any, schema:SchemaElement, refs):ModelElement
    {
        var mel = this.create(schema);
        var melInfo = mel.getInfo();

        for (var member in obj)
        {
            if (!obj.hasOwnProperty(member))
                continue;

            var val = obj[member];
            var prop = melInfo.schemaElement.getProperty(member, true);
            if (prop)
            {
                mel.setPropertyValue(
                    prop, prop.deserialize(
                        new SerializationContext(
                            this, melInfo.id, undefined, undefined, undefined, undefined, val
                        )
                    )
                );
                continue;
            }

            var rel = melInfo.schemaElement.getReference(member, true);
            if (rel)
            {
                var endSchema = this.store.getSchemaEntity(rel.schemaRelationship.endSchemaId);
                var values = val;
                if (Utils.isArray(val))
                {
                    if (!rel.isCollection)
                    {
                        throw "Property " + member + " must be a collection";
                    }
                }
                else
                {
                    values = [val];
                    if (rel.isCollection)
                    {
                        throw "Property " + member + " must not be a collection";
                    }
                }

                for (var i in values)
                {
                    var v = values[i];
                    var elem:ModelElement;
                    if (v.$ref)
                    {
                        elem = refs[v.$ref];
                    }
                    else
                    {
                        elem = this.parseJson(v, endSchema, refs);
                    }

                    var src = rel.opposite
                        ? elem
                        : mel;
                    var end = rel.opposite
                        ? mel
                        : elem;

                    var domain = src.getInfo().domain;
                    if (!domain.getRelationships(rel.schemaRelationship, src, end).hasNext() && end)
                    {
                        var endInfo = end.getInfo();
                        domain.createRelationship(rel.schemaRelationship, src, endInfo.id, endInfo.schemaElement.id);
                    }

                    if (v.$id)
                    {
                        refs[v.$id] = elem;
                    }

                }
            }
        }
        return mel;
    }

    private loadFromHyperstoreJson(def):Array<ModelElement>
    {
        var list = [];
        var session = this.store.beginSession();
        try
        {
            for (var k = 0; k < def.entities.length; k++)
            {
                var entity = def.entities[k];
                var entityId = this.createId(entity["id"]);
                if (entity.state && entity.state === "D")
                {
                    this.remove(entityId, entity.v);
                    continue;
                }

                var elem;
                var schemaId = this.findSchemaId(def.schemas, entity["schema"]);
                var schema = this.store.getSchemaElement(schemaId);
                if (!this.elementExists(entityId))
                {
                    list.push(elem = this.create(schema, entityId));
                }

                if (entity.properties)
                {
                    for (var kprop in entity.properties)
                    {
                        var prop = entity.properties[kprop];
                        var propDef = schema.getProperty(<string>prop.name, true);
                        if (propDef)
                        {
                            var v = prop.value;
                            this.setPropertyValue(entityId, propDef, v);
                        }
                    }
                }
            }

            if (def.relationships)
            {
                for (var k = 0; k < def.relationships.length; k++)
                {
                    var relationship = def.relationships[k];
                    var entityId = this.createId(relationship["id"]);
                    if (relationship.state && relationship.state === "D")
                    {
                        this.remove(entityId, relationship.v);
                        continue;
                    }

                    var schemaId = this.findSchemaId(def.schemas, relationship["schema"]);
                    var schema = this.store.getSchemaElement(schemaId);

                    if (!this.elementExists(entityId))
                    {
                        var start = this.get(this.createId(relationship.startId));
                        this.createRelationship(
                            <SchemaRelationship>schema, start, this.createId(relationship.endId),
                            this.findSchemaId(def.schemas, relationship.endSchemaId), entityId
                        );
                    }

                    if (relationship.properties)
                    {
                        for (var kprop in relationship.properties)
                        {
                            var prop = relationship.properties[kprop];
                            var propDef = schema.getProperty(<string>prop.name, true);
                            if (propDef)
                            {
                                var v = prop.value;
                                this.setPropertyValue(entityId, propDef, v);
                            }
                        }
                    }
                }
            }
            session.acceptChanges();
        }
        finally
        {
            session.close();
        }
        return list;
    }

    /**
     * Get relationships of the domain filtered by schema or terminal elements.
     * Filters can be combined.
     * @param schemaElement: Select only relationships of this schema (including inheritance)
     * @param start: Select outgoing relationships of 'start'
     * @param end : Select incoming relationships of 'end'
     * @returns {ModelElement[]}
     */
    getRelationships(schemaElement?:SchemaRelationship, start?:ModelElement, end?:ModelElement):ICursor
    {
        var currentSchema = <SchemaElement>schemaElement;
        var tmpSchema = currentSchema;

        if (start)
        {
            var metadata = start.getInfo();
            var node = this.graph.getNode(metadata.id);
            if (node)
            {
                return node.outgoings
                    .map( info =>
                     {
                         if (end && end.getInfo().id !== info.endId)
                         {
                             return null;
                         }

                         if (!tmpSchema || info.schemaId !== tmpSchema.id)
                         {
                             tmpSchema = this.store.getSchemaElement(info.schemaId);
                         }
                         if (!tmpSchema.isA(schemaElement.id))
                         {
                             return null;
                         }

                         return this.getFromCache(
                             tmpSchema, metadata.id, metadata.schemaElement.id, info.endId,
                             info.endSchemaId, info.id
                         );
                     }
                );
            }
        }
        else if (end)
        {
            var metadata = start.getInfo();
            var node = this.graph.getNode(metadata.id);
            if (node)
            {
                return node.incomings
                    .map( info => {
                         if (!tmpSchema || info.schemaId !== tmpSchema.id)
                         {
                             tmpSchema = this.store.getSchemaElement(info.schemaId);
                         }
                        if (!tmpSchema.isA(schemaElement.id))
                        {
                            return null;
                        }

                        return this.getFromCache(
                            tmpSchema, info.endId, info.endSchemaId, metadata.id, metadata.schemaElement.id, info.id
                        );
                    });
            }
        }
        else
        {
            return this.graph.getNodes(NodeType.Relationship, schemaElement)
                .map(info=>
                {
                    if (!tmpSchema || info.schemaId !== tmpSchema.id)
                    {
                        tmpSchema = this.store.getSchemaElement(info.schemaId);
                    }
                    if (tmpSchema.isA(schemaElement.id))
                    {
                        return this.getFromCache(
                            tmpSchema, info.startId, info.startSchemaId, info.endId, info.endSchemaId, info.id
                        );
                    }

                    return undefined;
                }
            );
        }
        return Cursor.emptyCursor;
    }

    /**
     * get value of an element property in the underlying hypergraph.
     * Returns 'undefined' if the value doesn't exist and no defaultValue is set in the property schema.
     * Otherwise, returns a PropertyValue {value, version}
     * @param ownerId
     * @param property
     * @returns {*}
     */
    getPropertyValue(ownerId:string, property:SchemaProperty):PropertyValue
    {
        var owner = this.graph.getNode(ownerId);
        if (!owner)
        {
            throw "Invalid element " + ownerId;
        }

        var node = this.graph.getPropertyNode(owner, property.name);
        var value = undefined;

        if (!node)
        {
            var def = property.defaultValue;
            if (!def)
            {
                return undefined;
            }
            return new PropertyValue(typeof(def) === "function" ? def() : def, undefined, 0);
        }

        return new PropertyValue(node.value, undefined, node.version);
    }

    /**
     * set value of an element property
     * @param ownerId
     * @param property
     * @param value
     * @param version
     * @returns {Hyperstore.PropertyValue} {value, oldValue, version}
     */
    setPropertyValue(ownerId:string, property:SchemaProperty, value:any, version?:number):PropertyValue
    {
        var ownerNode = this.graph.getNode(ownerId);
        if (!ownerNode)
        {
            throw "Invalid element " + ownerId;
        }

        var node = this.graph.getPropertyNode(ownerNode, property.name);
        var oldValue = undefined;

        if (!node)
        {
            node = this.graph.addPropertyNode(ownerNode, property.name, property.schemaProperty.id, value, version || Utils.getUtcNow());
        }
        else
        {
            oldValue = node.value;
            node.value = value;
            node.version = version || Utils.getUtcNow();
            this.graph.updatePropertyNode(ownerNode, node);
        }

        var pv = new PropertyValue(value, oldValue, node.version);
        this._raiseEvent(
                new ChangePropertyValueEvent(
                    this.name,
                    ownerId,
                    ownerNode.schemaId,
                    property.name,
                    property.serialize(pv.value),
                    property.serialize(pv.oldValue),
                    pv.version
                )
        );
        return pv;
    }

    /**
     * create a new domain entity using the specified schema
     * @param schemaElement
     * @param id
     * @param version
     * @returns {Hyperstore.ModelElement}
     */
    create(schemaElement:SchemaElement, id?:string, version?:number):ModelElement
    {
        Utils.Requires(schemaElement, "schemaElement");
        if (typeof(schemaElement) == "string")
            schemaElement = this.store.getSchemaEntity(<any>schemaElement);

        if (!id)
        {
            id = this.createId();
        }
        var node = this.graph.addNode(id, schemaElement.id, version);
        // after node creation
        var mel = <ModelElement>schemaElement.deserialize(new SerializationContext(this, id));
        this._raiseEvent(
            new AddEntityEvent(this.name, id, schemaElement.id, node.version)
        );
        this._cache[id] = mel; // TODO cache mel in node and remove _cache
        return mel;
    }

    /**
     * create a new domain relationship using the specified schema
     * @param schemaRelationship
     * @param start
     * @param endId
     * @param endSchemaId
     * @param id
     * @param version
     * @returns {Hyperstore.ModelRelationship}
     */
    createRelationship(schemaRelationship:SchemaRelationship, start:ModelElement, endId:string, endSchemaId:string, id?:string, version?:number):ModelRelationship
    {
        Utils.Requires(schemaRelationship, "schemaRelationship");
        Utils.Requires(start, "start");
        Utils.Requires(endId, "endId");
        if (typeof(schemaRelationship) == "string")
            schemaRelationship = this.store.getSchemaRelationship(<any>schemaRelationship);

        if (!id)
        {
            id = this.createId();
        }

        var src = start.getInfo();
        var node = this.graph.addRelationship(
            id, schemaRelationship.id, src.id, src.schemaElement.id, endId, endSchemaId, version
        );
        // after node creation
        var mel = <ModelRelationship>schemaRelationship.deserialize(
            new SerializationContext(this, id, src.id, src.schemaElement.id, endId, endSchemaId)
        );

        this._raiseEvent(new AddRelationshipEvent(
            this.name, id, schemaRelationship.id, src.id, src.schemaElement.id, endId, endSchemaId, node.version)
        );

        this._cache[id] = mel; // TODO cache mel in node
        return mel;
    }

    onEventRaised(evt:AbstractEvent) {

    }

    private _raiseEvent(evt) {
        this.store.runInSession(
            () => {
                if( Array.isArray(evt)) {
                    Utils.forEach(evt, e=> {Session.current.addEvent(e); this.onEventRaised(e);});
                }
                else {
                    Session.current.addEvent(evt);
                    this.onEventRaised(evt);
                }
            }
        );
    }

    /**
     * remove an element (entity or relationship)
     * @param id
     * @param version
     */
    remove(id:string, version?:number)
    {
        var events = this.graph.removeNode(id, version);
        this._raiseEvent(events);

        Utils.forEach(events, e => {
                var mel = this._cache[e.id];
                if (mel)
                {
                    mel.dispose();
                    delete mel;
                }
            }
        );
    }

    /**
     * check if an element (entity or relationship) exists
     * @param id
     * @returns {boolean}
     */
    elementExists(id:string):boolean
    {
        return !!this.graph.getNode(id);
    }

    /**
     * get an element (entity or relationship) by its id
     * @param id
     * @returns {*}
     */
    get(id:string):ModelElement
    {
        var node = this.graph.getNode(id);
        if (!node)
        {
            return undefined;
        }

        var schemaElement = this.store.getSchemaElement(node.schemaId);
        return this.getFromCache(
            schemaElement, node.startId, node.startSchemaId, node.endId, node.endSchemaId, node.id
        );
    }

    /**
     * Get all entities
     * @param schemaElement - filter on a specific schemaElement
     * @returns {ICursor} - a cursor
     */
    getEntities(schemaElement?:SchemaElement):ICursor
    {
        return this.getElements(schemaElement, NodeType.Entity);
    }

    /**
     * get a list of elements
     * @param schemaElement - filter on a specific schemaElement
     * @param kind - filter on a specific node type (entity or relationship)
     * @returns {ICursor} - a cursor
     */
    getElements(schemaElement?:SchemaElement, kind:NodeType = NodeType.EntityOrRelationship):ICursor
    {
        if (typeof (schemaElement) === "string")
        {
            schemaElement = this.store.getSchemaElement(schemaElement.toString());
        }
        var _this = this;

        return this.graph.getNodes(kind, schemaElement)
            .map(
            function (node)
            {
                var schemaElement = _this.store.getSchemaElement(node.schemaId);
                return _this.getFromCache(
                    schemaElement, node.startId, node.startSchemaId, node.endId, node.endSchemaId, node.id
                );
            }
        );
    }

    private getFromCache(schemaElement:SchemaElement, startId?:string, startSchemaId?:string, endId?:string, endSchemaId?:string, id?:string)
    {
        var mel = this._cache[id];
        if (mel)
        {
            return mel;
        }
        mel = schemaElement.deserialize(new SerializationContext(this, id, startId, startSchemaId, endId, endSchemaId));
        this._cache[mel.id] = mel;
        return mel;
    }
}

    export class DomainModelScope extends DomainModel {
        private _events: AbstractEvent[];

        constructor(public domain:DomainModel, extension:string)
        {
            super(domain.store, domain.name, extension);
            var that:any = this;
            // simulate graph property as protected
            that.graph = new HypergraphEx(domain);
            this._events = [];
        }

        onEventRaised(evt:AbstractEvent) {
            this._events.push(evt);
        }

        apply(dispatcher?:EventDispatcher) {
            this.store.runInSession(() => {
                var d = new DomainEventDispatcher(this.domain, dispatcher || this.store.eventBus.defaultEventDispatcher);
                this._events.forEach(e => {
                    d.handleEvent(e);
                });
            });
        }

       // getFromCache(id) {}
    }

    class Hypergraph
    {
        _deletedNodes:number = 0;
        _nodes;
        _keys;
        _properties;
        static DELETED_NODE = '$';

        constructor(public domain:DomainModel)
        {
            this._properties = {};
            this._nodes = [];
            this._keys = {};
        }

        dispose()
        {
            this._keys = null;
            this._nodes = null;
            this._properties = null;
        }

        getKey(id) {
            return this._keys[id];
        }

        private addNodeCore(node) : GraphNode {
            var n = this.getKey(node.id);
            if (n !== undefined && n !== Hypergraph.DELETED_NODE)
            {
                throw "Duplicate element " + node.id;
            }

            this._keys[node.id] = this._nodes.push( node ) - 1;
            return node;
        }

        addNode(id:string, schemaId:string, version:number):GraphNode
        {
            var node = new GraphNode(id, schemaId, NodeType.Entity, version);
            return this.addNodeCore(node);
        }

        updateNode(node:GraphNode)
        {
            // when a node is update but doesn't exist yet in the extension
            // needsUpdate flag is set on the getPropertyNode of the hypergraphex
            if( (<any>node).needsUpdate)
                this._keys[node.id] = this._nodes.push( node ) - 1;
        }

        updatePropertyNode(owner:GraphNode, node:GraphNode)
        {
            // when a node is update but doesn't exist yet in the extension
            // needsUpdate flag is set on the getPropertyNode of the hypergraphex
            if( (<any>node).needsUpdate)
                owner.properties[node.id] = node;
        }

        addPropertyNode(owner:GraphNode, id:string, schemaId:string, value:any, version:number):GraphNode
        {
            var node = new GraphNode(
                id, schemaId, NodeType.Property, version, undefined, undefined, undefined, undefined, value
            );
            return owner.properties[node.id] = node;
        }

        getPropertyNode(owner:GraphNode, name:string) : GraphNode {
            return owner.properties[name];
        }

        addRelationship(id:string, schemaId:string, startId:string, startSchemaId:string, endId:string, endSchemaId:string, version:number):GraphNode
        {
            var start = this.getNode(startId);
            if (!start)
            {
                throw "Invalid start element " + startId + " when adding relationship " + id;
            }

            var node = new GraphNode(id, schemaId, NodeType.Relationship, version, startId, startSchemaId, endId, endSchemaId);
            this.addNodeCore(node);

            if (startId === endId)
            {
                start.addEdge(id, schemaId, Direction.Both, startId, startSchemaId);
                this.updateNode(start);
                return node;
            }

            start.addEdge(id, schemaId, Direction.Outgoing, endId, endSchemaId);
            this.updateNode(start);
            var end = this.getNode(endId);
            if (end)
            {
                end.addEdge(id, schemaId, Direction.Incoming, startId, startSchemaId);
                this.updateNode(end);
            }
            return node;
        }

        getNode(id:string):GraphNode
        {
            var n = this._keys[id];
            return (n !== undefined && n !== Hypergraph.DELETED_NODE) ? this._nodes[n] : undefined;
        }

        removeNode(id:string, version:number):AbstractEvent[]
        {
            var events = [];
            var revents = [];

            var node = this.getNode(id);
            if (!node)
            {
                return events;
            }
            if (!version)
            {
                version = Utils.getUtcNow();
            }

            var sawNodes = {};

            // Cascading
            this.traverseNodes(
                node, node=>
                {
                    sawNodes[node.id] = true;
                    var evt;
                    if (!node.startId)
                    {
                        evt = new RemoveEntityEvent(
                            this.domain.name, node.id, node.schemaId, version
                        );
                    }
                    else
                    {
                        evt = new RemoveRelationshipEvent(
                            this.domain.name, node.id, node.schemaId, node.startId, node.startSchemaId, node.endId,
                            node.endSchemaId, version
                        );
                    }
                    evt.TL = node.id === id; // top level event
                    events.push(evt)

                    // don't replay cascading during rollback or undo/redo
                    if (Session.current.mode & (
                        SessionMode.Rollback | SessionMode.UndoOrRedo))
                        return null;

                    var nodes = [];
                    node.outgoings.forEach(edge =>
                    {
                        if (!sawNodes[edge.id])
                        {
                            sawNodes[edge.id] = true;
                            nodes.push(this.getNode(edge.id));
                        }
                    });

                    node.incomings.forEach(edge =>
                    {
                        if (!sawNodes[edge.id])
                        {
                            sawNodes[edge.id] = true;
                            nodes.push(this.getNode(edge.id));
                        }
                    });

                    if (node.startId)
                    {
                        var schema = this.domain.store.getSchemaRelationship(node.schemaId);
                        if (schema.embedded)
                        {
                            if (!sawNodes[node.endId])
                            {
                                sawNodes[node.endId] = true;
                                nodes.push(this.getNode(node.endId));
                            }
                        }
                    }

                    return nodes;
                }
            );

            events = revents.concat(events);
            var pevents = [];
            events.forEach(e=> this.removeNodeInternal(e.id, sawNodes, pevents));
            if( this._deletedNodes > 1000)
                this.shrink();
            return pevents.concat(events);
        }

        private shrink() {
            var nodes = [];
            for(var key in this._keys) {
                var n = this._keys[key];
                if( n === Hypergraph.DELETED_NODE)
                    continue;
                this._keys[key] = nodes.push(this._nodes[n]) - 1;
            }
            this._nodes = nodes;
            this._deletedNodes = 0;
        }

        private removeNodeInternal(id:string, sawNodes, events:AbstractEvent[])
        {
            var index = this.getKey(id);
            if (index === undefined || index === Hypergraph.DELETED_NODE)
            {
                return;
            }

            var node = this._nodes[index];
            this._nodes[index] = null;
            this._deletedNodes++;
           // if( this.domain.store.keepDeletedNodes)
                this._keys[id] = Hypergraph.DELETED_NODE;
           // else
           //     delete this._keys[index];

            if (node.kind === NodeType.Relationship)
            {
                var start = this.getNode(node.startId);
                if (!start)
                {
                    throw "Invalid element " + node.startId;
                }

                if (node.startId == node.endId)
                {
                    start.removeEdge(id, Direction.Both);
                    this.updateNode(start);
                    return node;
                }
                else {
                    start.removeEdge(id, Direction.Outgoing);
                    this.updateNode(start);

                    var end = this.getNode(node.endId);
                    if (end) {
                        end.removeEdge(id, Direction.Incoming);
                        this.updateNode(end);
                    }
                }
            }

            var schema = this.domain.store.getSchemaElement(node.schemaId);
            var self = this;
            schema.getProperties(true).forEach(
                p=>
                {
                    var pnode = node.properties[p.name];
                    if (pnode)
                    {
                        events.push(
                            new RemovePropertyEvent(
                                self.domain.name, node.id, node.schemaId, p.name, pnode.value,
                                pnode.version
                            )
                        );
                    }
                }
            );
        }

        traverseNodes(startNode:GraphNode, visit:(node:GraphNode) => GraphNode[])
        {
            var queue = [];
            queue.push(startNode);

            while (queue.length > 0)
            {
                var node = queue.pop();
                if (!node)
                {
                    continue;
                }

                var nodes = visit(node);
                if (!nodes)
                {
                    return;
                }

                for (var k in nodes)
                {
                    node = nodes[k];
                    queue.unshift(node);
                }
            }
        }

        getNodes(kind:NodeType, schema?:SchemaElement): NodesCursor
        {
            return new NodesCursor(this, kind, schema);
        }

    }

    class HypergraphEx extends Hypergraph {
        private _superHyperGraph:Hypergraph;

        constructor(domain:DomainModel) {
            super(domain);
            this._superHyperGraph = (<any>domain).graph;
        }

        getKey(id) {
            return this._keys[id] || this._superHyperGraph.getKey(id);
        }

        getPropertyNode(owner:GraphNode, name:string) : GraphNode {
            var node = super.getPropertyNode(owner, name);
            if( node )
                return node;

            owner = this._superHyperGraph.getNode(owner.id);
            if( !owner) return owner;
            node = this._superHyperGraph.getPropertyNode(owner, name);
            if( !node) return node;
            // add a flag to force the update if this read is for an update
            node = node.clone();
            node.needsUpdate = true;
            return node;
        }

        getNode(id:string):GraphNode
        {
            var n = this._keys[id];
            if (n !== undefined ) {
                return n !== Hypergraph.DELETED_NODE ? this._nodes[n] : undefined;
            }
            var node = this._superHyperGraph.getNode(id);
            if( !node) return node;
            // add a flag to force the update if this read is for an update
            node = node.clone();
            node.needsUpdate = true;
            return node;
        }
    }

    export interface ICursor {
        hasNext():boolean;
        next:any;
        reset();
    }

    export class Cursor implements ICursor {
        reset() {}
        hasNext():boolean {return false;}
        next() {return undefined;}

        static emptyCursor = new Cursor();

        firstOrDefault(callback?) {
            this.reset();
            while(this.hasNext()) {
                var r = this.next();
                if(!callback || callback(r))
                    return r;
            }
            return undefined;
        }

        forEach(callback) {
            this.reset();
            while(this.hasNext()) {
                callback(this.next());
            }
        }

        count(callback?) : number {
            var cx=0;
            this.reset();
            while(this.hasNext()) {
                if( !callback || callback(this.next()))
                    cx++;
            }
            return cx;
        }

        concat(list:ICursor) : ICursor {
            return new ConcatCursor(this, list);
        }

        any(callback?) : boolean {
            this.reset();
            while(this.hasNext()) {
                if( !callback || callback(this.next()))
                    return true;
            }
            return false;
        }

        toArray() : any[] {
            var list = [];
            this.forEach(n=>list.push(n));
            return list;
        }

        map(callback) : ICursor {
            return new MapCursor(this, callback);
        }

        static from(obj) : ICursor {
            if( Array.isArray(obj))
                return new ArrayCursor(obj);

            if(obj.hasNext)
                return obj;

            throw "Not implemented";
        }
    }

    class ConcatCursor extends Cursor {
        private _cursors : ICursor[];
        private _idx:number;

        constructor(...cursors : ICursor[]) {
            super();
            this.reset();
        }

        reset() {
            this._idx = 0;
            if( this._cursors.length > 0 )
                this._cursors[0].reset();
        }

        hasNext() : boolean {
            if( this._idx < this._cursors.length) {
                var r =  this._cursors[this._idx].hasNext();
                if( r )
                    return true;
                this._idx++;
                if( this._idx < this._cursors.length) {
                    this._cursors[this._idx].reset();
                    return this._cursors[this._idx].hasNext();
                }
            }
            return false;
        }

        next() {
            return this._idx < this._cursors.length ? this._cursors[this._idx].next() : undefined;
        }
    }

    class MapCursor extends Cursor {
        private _current;

        constructor( private _cursor:ICursor, private _filter) {
            super();
            this.reset();
        }

        reset() {
            this._cursor.reset();
            this._current = undefined;
        }

        hasNext() : boolean {
            while(true) {
                if( !this._cursor.hasNext())
                    return false;
                var r = this._filter(this._cursor.next());
                if( r ) {
                    this._current = r;
                    return true;
                }
            }
        }

        next() {
            return this._current;
        }
    }

    class ArrayCursor extends Cursor implements ICursor {
        private _index:number;

        constructor(private _array) {
            super();
            this.reset();
        }

        reset() {
            this._index = 0;
        }

        hasNext() : boolean {
            if( this._index === this._array.length)
                return false;
            this._index++;
            return true;
        }

        next() : any {
            return this._array[this._index-1];
        }
    }

    class NodesCursor extends Cursor implements ICursor {
        private _index : number;
        private _current : GraphNode;

        constructor(private _graph:Hypergraph, private _kind:NodeType, private _schema:SchemaElement) {
            super();
            this.reset();
        }

        reset() {
            this._index = 0;
            this._current = undefined;
        }

        hasNext() : boolean {
            while(true) {
                if( this._index === this._graph._nodes.length) {
                    this._current = undefined;
                    return false;
                }
                this._index++;
                var node = this._graph._nodes[this._index-1];
                if( node && node !== Hypergraph.DELETED_NODE && (node.kind & this._kind) !== 0
                    && (!this._schema || this._schema.id === node.schemaId))
                {
                    this._current = node;
                    return true;
                }
            }
        }

        next() : any {
            return this._current;
        }
    }
    /**
     *
     */
    export enum Direction
    {
        Incoming = 1,
        Outgoing = 2,
        Both = 3
    }

    /**
     * Type of element in the graph model
     */
    export enum NodeType
    {
        /**
         * Element is an entity
         */
        Entity = 1,
        /**
         * Element is a relationship
         */
        Relationship = 2,
        /**
         * Value used for query only
         */
        EntityOrRelationship = 3,
        /**
         * Element is a property (Do not use this value in a query)
         * @type {number}
         */
        Property = 4
    }

    class NodeInfo
    {
        constructor(public id:string, public schemaId:string, public version:number)
        {
            if (!version)
            {
                this.version = Utils.getUtcNow();
            }
        }
    }

    class EdgeInfo extends NodeInfo
    {
        constructor(id:string, schemaId:string, version:number, public endId?:string, public endSchemaId?:string)
        {
            super(id, schemaId, version);
        }
    }

    class GraphNode extends EdgeInfo
    {
        outgoings:HashTable<string, EdgeInfo>;
        incomings:HashTable<string, EdgeInfo>;

        public properties : GraphNode[];
        public kind:NodeType;
        public startId:string;
        public startSchemaId:string;
        public needsUpdate:boolean;

        constructor(id:string, schemaId:string, kind:NodeType, version:number, startId?:string, startSchemaId?:string, endId?:string, endSchemaId?:string, public value?:any, outgoings?:HashTable<string, EdgeInfo>, incomings?:HashTable<string, EdgeInfo>)
        {
            super(id, schemaId, version, endId, endSchemaId);

            this.kind = kind;
            this.startId = startId;
            this.startSchemaId = startSchemaId;

            this.properties = [];
            this.outgoings = outgoings && outgoings.clone() || new HashTable<string, EdgeInfo>();
            this.incomings = incomings && incomings.clone() || new HashTable<string, EdgeInfo>();
        }

        clone() : GraphNode  {
            var node = new GraphNode(this.id, this.schemaId, this.kind, this.version, this.startId, this.startSchemaId, this.endId, this.endSchemaId, this.value, this.outgoings, this.incomings);
            return node;
        }

        addEdge(id:string, edgeSchemaId:string, direction:Direction, endId:string, endSchemaId:string)
        {
            var edge = new EdgeInfo(id, edgeSchemaId, undefined, endId, endSchemaId);

            if ((direction & Direction.Incoming) === Direction.Incoming)
            {
                this.incomings.add(id, edge);
            }
            if ((direction & Direction.Outgoing) === Direction.Outgoing)
            {
                this.outgoings.add(id, edge);
            }
        }

        removeEdge(id:string, direction:Direction)
        {
            if ((direction & Direction.Incoming) === Direction.Incoming)
            {
                this.incomings.remove(id);
            }
            if ((direction & Direction.Outgoing) === Direction.Outgoing)
            {
                this.outgoings.remove(id);
            }
        }
    }
}